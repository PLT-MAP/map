{"name":"Map","tagline":"","body":"## What is MAP?\r\nMap is a graphing programming language intended to make graph programming easier. Unlike other languages, MAP includes the derived types relevant to graph programming, such as edges, nodes, graphs, and paths as inherent data structures. \r\n\r\n## Language Tutorial\r\n### Introduction\r\nThis will be a brief walkthrough of the mechanics of the MAP language. The aim is to show the essential elements of the language in real programs, without focusing too much on details, rules and exceptions. The ultimate goal is to allow users to attain the tools and skills to be able to write their own creative and useful programs.\r\n\r\nIn this brief tutorial, there will be several sample programs that demonstrate the multiple usages of the language. The main focus will be on the basics: variables and constants, arithmetic operations, control flow, functions, and the correct application of inputs and outputs. Specifically, a user will be able to learn how to implement the different graph data structures available in the language and learn how to quickly build nodes and edges without needing to know the specifics of how the graphs are implemented.\r\n\r\nExperienced programmers should easily be able to extrapolate the material in this tutorial to meet their own programming needs. New users can easily pick up the basics of MAP by slowly building their knowledge by starting from small, similar programs and expanding to longer and more advanced programs. Either way, both subsets of programmers should be able to efficiently use this tutorial as a framework for any projects they wish to work on in the future. \r\n\r\n### Input and Output\r\nThe purpose of MAP is to create and implement graph data structures much more efficiently and easily. As such, the general output will be a visual representation of the graph in the form of an associative array. The input will usually be data entered by the user or from a file, and that will be used to populate the graph. To prompt a user, a programmer can use the command:\r\n```\r\ninput(\"prompt\")\r\n```\r\nFor a visual example of a undirected graph, please use the example below. Array 1 includes all the Nodes, and Array 2 includes the associate array of costs for each respective Node, so costs2 could be an associative array such as: \r\n```\r\n('sanfran', {'cost':280,'duration':6})\r\n```\r\nand the information stored in Array 2 for this connection could be:\r\n\r\nArray 1: Nodes | Array 2: Edges\r\n--- | --- \r\nNode 1 | ('Node 2','Node 1',{costs2})\r\nNode 2 | ('Node 1','Node 2',{costs3}), ('Node 3','Node 2',{costs4})\r\nNode 3 | ('Node 4','Node 3',{costs5}), ('Node 2','Node 3',{costs6})\r\nNode 4 | ('Node 2','Node 4',{costs7}), ('Node 3','Node 4',{costs8})\r\n```\r\nGraph g = new Graph():\r\n```\r\nAssume this graph is filled in with Nodes and Edges. Suppose if you wanted to print the graph out in a user-friendly and readable format, in MAP you would call: \r\n```\r\nprint(g);\r\n```\r\nThis would print the graph out in a similar format to this: \r\n```\r\nNODES\r\n1. Node1\r\n2. Node2\r\n3. Node3\r\n4. Node4\r\n\r\nEDGES\r\n(1->2)-costs2\r\n(2->1)-costs3\r\n(2->3)-costs4\r\n(3->4)-costs5\r\n(3->2)-costs6\r\n(4->2)-costs7\r\n(4->3)-costs8\r\n```\r\nThe print function simplifies the programming and formatting issues that programmers usually face when doing graph programming. \r\n\r\nAdditionally, MAP allows for printing of Edge values, Node values, text values, and numeric values. \r\n```\r\n\tNode la = new Node({'temp':78});\r\n\tprint(la);\r\n```\r\nwould give:\r\n```\r\n\t('la', {'temp':78})\r\n\r\n\tDirEdge flight234 = new DirEdge(newyork, sanfran, {'cost': 280,'duration': 6});\r\n\tprint(flight234);\r\n```\r\nwould give:\r\n```\r\n\t(newyork->sanfran) - cost: 280, duration: 6\r\n\t\r\n\tText temp = \" hello\";\r\n\tNumeric num = 1; \r\n\tprint(num + temp);\r\n```\r\nwould give:\r\n```\r\n\t1 hello\r\n```\r\n\r\n\r\n### Hello World\r\nTo begin the tutorial on how to write programs in MAP, we will walk through the very simple, but standard, Hello World program. Program 1 is a Hello World program, which when compiled and run will print the sentence “Hello, World!”\r\n```\r\nProgram 1:\r\nfunc main() {\r\n\tText t = \"Hello, World!\";\r\n\tprint(t);\r\n}\r\n```\r\nThe first line of this program is the declaration of the function called main. Every program in MAP needs a main function, which is what will be executed when the program is run. Every function declaration begins with the keyword func, followed by the function name, any parameters, and the bracket that begins (and later ends) the function body. \r\n\r\nThe second line of the program creates a variable t, of type Text, and stores the string “Hello, World!” in the variable as Text. Every line must be ended with a semicolon as well. \r\n\r\nThe third line uses the standard library function print, which can print any data type. The function print is passed the variable t, and the line is ended with a semicolon.\r\n\r\nThe last line simply contains the closing bracket, which signifies the end of the function. \r\n\r\nThis program is compiled and run by using the command:\r\n```\r\npython map.py helloworld.map\r\n```\r\nIf everything goes as it is supposed to, “Hello, World!” should be printed to the console. \r\n\r\n\r\n### Variables and Expressions\r\nProgram 2 is a GCD program, which means it calculates the greatest common divisor of two numbers given. This program is slightly more complicated than the Hello World program, and will help show how other aspects of MAP are used, such as variables, expressions, and operators. \r\n```\r\nProgram 2:\r\nfunc gcd(Numeric a, Numeric b) {\r\n\tif (b == 0) {\r\n\t\treturn a;\r\n\t} else {\r\n\t\treturn gcd(b, a % b);\t// recursive call\r\n\t}\r\n}\r\n\r\nfunc main() {\r\n\tNumeric x = 3 + 5 * 14;\t// 73\r\n\tNumeric y = 89;\r\n\r\n\tNumeric result = gcd(x, y);\r\n\tprint(\"The gcd of \" + x + \" and \" + y + \" is \" + result);\r\n}\r\n```\r\nThe first thing to notice about this program is there are two separate functions, a function that does the GCD computation, and a main function. \r\n\r\nThe GCD function follows a simple algorithm that recursively calculates the GCD. The first line declares the function, which in this case takes in two parameters, both of type Numeric. The function body is started with the opening bracket. \r\n\r\nThe first line of the function makes use of an if statement, to check whether the parameter b passed in is equal to 0. This line is ended with another opening bracket, which in this case signifies the start of the body of the if statement. \r\n\r\nThe if statement body only has one line, which says to return the parameter a that was passed in, if the parameter b is equal to 0. This line is ended with a semicolon, which is then followed by a closing bracket to end the body of the if statement. \r\n\r\nThe if is then followed by an else, which has its own opening and closing brackets around its body as well. The body of the else is a line that has a return statement that returns a call to the same function, modifying the parameters by calling GCD with b, and a % b (a modulus b, returning the remainder from a divided by b) as the new parameters. \r\n\r\nAfter the semicolon at the end of the line there is the special character constant \\\\\\\\. This symbolizes a comment, and is not part of the executed code. The function is ended with a closing bracket. \r\n\r\nThe main function begins with a function declaration and the opening bracket to start the body. The first two lines of the main declare two variables of type Numeric, and set them to numerical values. The first of these declarations shows operator precedence because multiplication has higher precedence than addition, so 5 * 14 is calculated before the 3 is added (the comment shows the value this should evaluate to, 73). The third line creates a variable called result to store the return from the function GCD, which is passed the variables created earlier. The last line of the main function prints this result out, and uses the + operator to concatenate strings with variables in order to print the output as one sentence. \r\n\r\nThis program is then compiled and run by typing the command:\r\n```\r\npython map.py gcd.map\r\n```\r\nIf all goes well, it should print out a sentence that gives the two numbers assigned to the variables in main, and the greatest common divisor of them. \r\n\r\n\r\n### Control Flow\r\n\r\n#### If-elif-else Statements\r\nTo perform different actions based on different conditions, MAP supports if-elif-else statements to properly direct control flow.\r\n```\r\nif (expression-1)\r\n{\r\n    statement-1-list\r\n}\r\nelif (expression-2)\r\n{\r\n    statement-2-list\r\n}\r\nelse\r\n{\r\n    statement-else-list\r\n}\r\n```\r\nHere is an example that implements this statement:\r\n```\r\nif (n['temp'] < 30 & n['temp'] > 0)\r\n{\r\n    graph1.add(n);\r\n}\r\nelif (n['temp'] < 70)\r\n{\r\n    graph2.add(n);\r\n}\r\nelse\r\n{\r\n    print(\"This location is too hot.\");\r\n}\r\n```\r\nIf the temperature of a node is greater than 0, but less than 30, then the node will be added to graph1. However, if this expression is false, then the elif expression is checked. If the elif expression is true, then the node is added to graph 2. Otherwise, the else statement will be executed and the standard output will state “This location is too hot.”\r\n\r\n#### Loops\r\nAbove, we learned about conditional statements, but now we will learn how to repeat statements by using two forms of the for loop.\r\n\r\nHere is a simple example using the first for loop, which also demonstrates nested loops:\r\n```\r\nfor (int x = 0; x < 10; x = x+1) {\r\n    print(x + \" \");\r\n    for (int y = 0; y < 10; y = y+1) {\r\n        print(x*y + \" \");\r\n    }\r\n}\r\n```\r\nThis snippet of code will basically print out a small multiplication table. For both for loops, inside the parentheses the first expression initializes a variable, the second expression is a condition that must be true in order for the loop to continue, and the third expression increases the variable by  1. For each x in the outer loop, the x will be printed and then the result of the multiplication of x and the numbers 0 to 9 will also be printed. The numbers 0 to 9 come from y in the inner for loop.\r\n\r\nHere is an example using the second for loop:\r\n```\r\nforeach (Node n in graph1) {\r\n    if (n['population'] < 8000000) {\r\n        graph2.add(n);\r\n    }\r\n}\r\n```\r\nA graph is made up of any number of nodes. Thus, in the foreach statement, it will keep repeating the statements in the loop until there are no more nodes in the graph. If there were no nodes in the graph initially, the foreach statement would not even execute. In the above example, a smaller subset of graph1 called graph2 is being created. For every node in graph1, if the population of the node is less than 8 million, that node will be added to graph2. The foreach statement could also be used with edges in graphs, nodes in paths, and edges in paths. \r\n\r\n\r\n### Functions\r\nMAP allows users to define their own functions in order to enhance reusability and even readability by treating a specific computation as a unit and to allow this computation to be repeated. Even if a function is only used once, it often helps clarify a piece of code. \r\n\r\nHere is the syntax for a function:\r\n```\r\nfunc func_name(param_list) {\r\n\tfunc_body;\r\n}\r\n```\r\nThe param_list can have any number of arguments and the function can end with return (expression) or return. If there is no return statement, the function will simply end as if return was placed at the end of the function body. \r\n\r\nHere is an example function that helps a user choose a location based on a budget:\r\n```\r\nfunc printNodes(Node origin, Numeric budget, Graph graph) {\r\n\tforeach (Node n in graph) {\r\n\t\tif (graph.adjacent(origin, n)) {\r\n\t\t\ttemp = graph.getEdge(origin,n);\r\n\t\t\tif (temp['cost'] <= budget) {\r\n\t\t\t\tprint(n);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nThis function will loop through all the nodes in a certain graph, check if each node is adjacent to the origin specified, and if it is adjacent and the cost of the edge is less than or equal to the user’s budget, the location is printed out. \r\n\r\nIn order to call this function, we only have to use its name and put in the parameters with the correct data types. Here is an example:\r\n```\r\nprintNodes(newark, 1000, graph1);\r\n```\r\nThis function is very reusable because the user can check different price ranges and even change the graph, which might have different attributes. Here is an example of a user checking different prices with different graphs:\r\n```\r\nfunc main() {\r\n\tGraph graph1 = new Graph();\r\n\tGraph graph2 = new Graph();\r\n\tNode newark = new Node();\r\n\tgraph1.add(newark);\r\n\tgraph2.add(newark);\r\n\tprintNodes(newark, 1000, graph1);\r\n\tprintNodes(newark, 2000, graph2);\r\n}\r\n```\r\nThis is obviously a simple example without any direct results. However, with the creation of larger graphs, this function could become very useful. Another important aspect to point out is that a main function is required in MAP. All the code in the main function will be executed. Additionally, functions have to be declared in the program before they are called or there will be a compiler error. \r\n\r\n\r\n### Create Your Own Graph\r\nNow that you are familiar with the basics of MAP - its variables, functions, file I/O, and control flow, we will focus on the driving motivation behind MAP's creation: the easy manipulation of graphs. In this section of the tutorial, we will create a graph, populate it with nodes, and see how MAP graphs utilize built-in and user-created functions. \r\n\r\n#### Graphs in MAP\r\nA graph is a set of nodes and their associated edges. A graph will be used to represent flights between various pairs of airports. Flights will be of DirEdge type, weighted by cost and duration, and airports will be Nodes, with specific characteristics like humidity and temperature. The reason that we use DirEdges (directed edges) instead of UndirEdges (undirected edges) is that flights imply a one direction movement. There might be up to two Flights associated with the same pair of cities; zero if the cities have no flight between them, one if there is a flight from city #1 to city #2 but not from city #2 to city #1, and two if there is a flight going both ways between the cities. \r\n\r\nWe start by creating an empty graph \r\n```\r\nGraph flights = Graph(); \r\n```\r\nTo populate the graph with city's airports, we create nodes for airports:\r\n```\r\nNode cabo    = new Node({'temp':85,'humidity':\"low\"});\r\nNode miami   = new Node({'temp':87,'humidity':\"high\"});\r\nNode ontario = new Node({'temp':45});\r\nNode seattle = new Node({'temp':60,'humidity':\"low\"});\r\nNode sanfran = new Node({'temp':75,'humidity':\"low\"});\r\nNode newyork = newNode({'temp':50,'humidity':\"medium\"});\r\nNode la      = new Node({'temp':78});\r\n```\r\nWe then add these nodes to the graph:\r\n```\r\nflights.add(cabo);\r\nflights.add(miami);\r\nflights.add(ontario);\r\nflights.add(seattle);\r\nflights.add(sanfran);\r\nflights.add(newyork);\r\nflights.add(la);\r\n```\r\nNote that, as our graph currently is, there is no connection among various airports, which is why we need to add edges to the graph between airports. Edges between two cities will be associated with two costs in our example: duration and cost. The DirEdges we use represent flights.\r\n```\r\nDirEdge flight5 = new DirEdge(newyork, seattle, {'cost':330,'distance':4092,\r\n                          'duration':6.5,'date':2014.03.14.6.25});\r\nDirEdge flight9 = new DirEdge(newyork, la, {'cost':256,'duration':6});\r\nDirEdge flight7 = new DirEdge(la, cabo, {'cost':180,'duration':2.5});\r\nDirEdge flight234 = new DirEdge(newyork, sanfran, {'cost': 280,'duration': 6});\r\nDirEdge flight49 = new DirEdge(seattle, cabo, {'cost':350,'duration':4.5});\r\n```\r\nNow add these edges to the graph to create connections among airports in our graph.\r\n\r\nYou can do this one edge at a time:\r\n```\r\nflights.addEdge(flight5);\r\nflights.addEdge(flight9);\t\r\nflights.addEdge(flight7);\r\nflights.addEdge(flight234);\t\r\nflights.addEdge(flight49);\r\n```\r\nor all at once:\r\n```\r\nflights.addEdge(flight5);\r\nflights.addedge(flight9);\r\nflights.addedge(flight7);\r\nflights.addedge(flight234);\r\nflights.addedge(flight49);\r\n```\r\nWith our graph set up, we can now begin to use MAP's built-in library functions. For example, if we wanted to know if there was a flight between New York and Los Angeles, and if so, how much would that trip cost and how long it would take, we could use the getEdge() built-in method as follows:\r\n```\r\nif (flights.getEdge(newyork, la) != null) {\r\n\tEdge temp = flights.getEdge(newyork, la);\r\n\tText t = \"There is a flight from\";\r\n\tText t2 = \" to \"; \r\n\tText t3 = \"The cost is\"; \r\n\tText t4 = \" and the duration is \";\r\n\tprint(t + temp['origin'] + t2 + temp['destination']);\r\n\tprint(t3 + temp['cost'] + t4 + temp['duration']); \r\n}\r\n```\r\nGraph programming typically requires much more coding and debugging, but MAP allows users to not have to worry about building a graph from scratch, and lets them instead focus on the manipulation of these graphs to produce meaningful results. In addition to the example provided, users can also write their own functions to use on MAP graphs. Though our example explores a graph with directed edges, MAP graphs additionally support undirected edges for connections between nodes that are equivalent regardless of which Node is the origin and which is the destination. \r\n\r\n\r\n### Conclusion\r\nThis tutorial for MAP covers the essential parts of this programming language and hopefully assists programmers of all levels in acquiring all the right tools in using this language effectively to its full potential. It especially showcases all the unique aspects of MAP and offers a very basic understanding of MAP’s grammar and syntax. A more detailed analysis of the inner workings of this language can be found in the Language Reference Manual.\r\n\r\n\r\n## Language Reference Manual\r\nWe've crafted some handsome templates for you to use. Go ahead and continue to layouts to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved if it remained markdown format.\r\n\r\n## Contributors\r\nSerena Simkus - Project Manager (@serenasimkus)\r\n\r\nSandya Sankarram - Language Guru\r\n\r\nAlex Merkulov - System Architect\r\n\r\nAlfred Tan - System Integrator\r\n\r\nTommy Inouye - Verification & Validation Person\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}