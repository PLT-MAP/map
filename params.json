{"name":"Map","tagline":"Language Reference Manual","body":"# Table of Contents\r\n1. [Language Reference Manual](#language-reference-manual)\r\n\r\n    1.1 [Introduction](#introduction)\r\n\r\n    1.2 [Lexical Conventions](#lexical-conventions)\r\n\r\n    1.3 [Data Types](#data-types)\r\n\r\n    1.4 [Expressions](#expressions)\r\n\r\n    1.5 [Function Definitions](#function-definitions)\r\n\r\n    1.6 [Statements](#statements)\r\n\r\n    1.7 [Scope](#scope)\r\n\r\n    1.8 [Built-in Functions](#built-in-functions)\r\n\r\n    1.9 [Preprocessing](#preprocessing)\r\n\r\n    1.10 [Grammar](#grammar)\r\n\r\n2. [Contributors](#contributors)\r\n\r\n## Language Reference Manual\r\n### Introduction \r\nThis manual describes MAP: the first ever travel-dedicated graphing programming language. This is a reliable guide to the proposed language. Furthermore, it describes the numerous features that MAP will use to deal with the problems and complexities of creating a graph data structure. The manual starts with an overview of lexical conventions used within this language, and moves onto the language syntax, and finishes with the grammar that is used to parse MAP.\r\n\r\n\r\n### Lexical Conventions\r\n\r\n#### Tokens\r\nEvery program is parsed to a series of tokens. Each token can be broken down to several categories: primitives, data types, operators, and standard library functions. In addition we have a few reserved words as well as white space and tabs that are dealt with as separate tokens.\r\n\r\n#### Comments\r\nMap uses // for single line comments that will extend to a newline character. Block comments start with /* and end with */ and everything in between these two characters will be ignored.\r\n\r\n#### Identifiers\r\nAn identifier can start with any letter, capital or lowercase, or an underscore. Every following character may include any letter, underscore or number. All identifiers are case sensitive and can be used to identify any basic or derived data types.\r\n\r\n#### Reserved Keywords\r\nThe following are reserved for use as keywords and cannot be used otherwise.\r\n\r\n|    |     |     |     |\r\n| --- | --- | --- | --- |\r\n| if | elif | else | for |\r\n| foreach | null | break | return |\r\n| continue | true | false | func |\r\n| in | include |  |  |\r\n\r\n#### Reserved Characters\r\nThe following characters are reserved for use in the grammar.\r\n\r\n|   |   |   |   |   |   |\r\n|---|---|---|---|---|---| \r\n| \\+ | - | * | / | % | [ |\r\n| ] | ( | ) | { | } | > |\r\n| >= | < | <= | == | != | = |\r\n| & | &#124; | , | . | // | /* |\r\n| */ | ; | : | ' | \" | ! |\r\n\r\n#### Constants\r\n##### Character Constants\r\nCharacter constants are strings whose values cannot be changed. Some special character constants can only be represented using the backslash escape character. Here are those special character constants:\r\n\r\nMeaning | Character   \r\n--- | --- \r\nnewline | \\\\n\r\nhorizontal tab | \\\\t\r\nbackslash | \\\\\r\nsingle quote | '\r\ndouble quote | \"\r\n\r\n##### Boolean Constants\r\nBoolean constants are either true or false.\r\n\r\n\r\n### Data Types\r\nMAP has three basic data types, and four derived data types that promote the use of graph data structures.\r\n\r\n#### Basic Data Types\r\n##### Boolean\r\nBooleans can either be true or false. The default value of a boolean is false. \r\n##### Numeric\r\nThe Numeric data type can hold any numeric value, including integers, doubles, floats, etc. MAP stores the values as floats, so it will handle as many decimal places and significant digits as allowed by the available memory on the machine. When values with decimals do not make sense, such as for indexing, the fractional part will be ignored. MAP simplifies primitive data types by lumping all numeric types into one type so that the user does not have to spend time thinking about which specific numeric type they will need. \r\n##### Text\r\nAny string, or any sequence of characters, surrounded by double quotes. \r\n\r\n#### Derived Data Types\r\nSince MAP is focused around making graph data structures easier to implement, there are many derived data types that are related to graphs. \r\n##### Edge\r\nThe Edge data type is used to represent an edge in a graph. There are two types of edges, directed edges and undirected edges. All edges have specified origin and destination nodes, and associated costs. When the user creates a directed edge, the order of the nodes listed matters because that is the direction, from source to destination. When the user creates an undirected edge they will just put in two nodes, and behind the scenes we will just create two directed edges, one going in each direction, to create their “undirected edge”. The associated cost attributes, origin, and destination are stored in associative arrays so they can be accessed with string indices. This will be done in the back end while the user will not have to write 'origin' and 'destination' to simplify the syntax.  Initializing a directed edge looks like this:\r\n```\r\nDirEdge flight5 = DirEdge('newyork','seattle',\r\n                          {'cost':330,'distance':4092,'duration':6.5});\r\n```\r\nwhere flight5 is the name of the edge, newyork is the origin node, seattle is the destination node, and the associative array holds the attributes of the edge, labeled cost, distance, duration, and date. An undirected edge will be initialized the same way, except the data type is UnDirEdge. \r\n##### Graph\r\nThe Graph data type represents a graph as a whole, containing nodes and edges. A graph can be initialized without any nodes or edges, and nodes and edges are added to the graph using built-in library functions. Initializing a graph called trip looks like this:\r\n```\r\nGraph trip = Graph();\r\n```\r\nGraphs will store their nodes and edges in an adjacency list with the associative array of costs related to the edge in the list. \r\n##### Node\r\nThe Node data type is used to represent a node in a graph. Nodes also have associative arrays to store attributes. Initializing a node looks like this:\r\n```\r\nNode cabo = Node({'temp':85,'humidity':\"low\"});\r\n```\r\nwhere the name of the node is cabo, and it has attributes of temp and humidity. \r\n##### Path\r\nThe Path data type is an ordered list of Nodes that provides a route from some start node to some end node. This can be used in finding a path through a graph such as the shortest path based on a specific cost attribute, or the path from one node to another node with specific attributes. Paths will be stored as lists, and will be created in the order that the path flows, from one node to another. Users can initialize paths like:\r\n```\r\nPath roadTrip = Path(graphName);\r\n```\r\nThe user passes in a parameter to specify which graph the path is associated with. The user can then add in nodes along the path from a graph. \r\n\r\n\r\n### Expressions\r\n\r\n#### Primary\r\nAn expression consists of at least one operand and zero or more operators. Operands can be made from any numeric values, constants, variables, or functions that return values. Parentheses can group subexpressions. Expressions are evaluated from left to right. Examples of expressions are:\r\n```\r\n3.14159\r\n4 + 13\r\n(((2 + 10) / (12 + 4)) * (27 - 14)) * 3.9\r\n```\r\n\r\n#### Operators\r\nOperators can be combined with operands to make expressions. \r\n##### Assignment Operators\r\nThe assignment operator is used to assign a value to a specified variable.\r\n```\r\nx = 3.1415;\r\ny = (2.9 * 1.3);\r\ngraph1 = graph2;\r\nnode1 = node2;\r\nedge1 = edge2;\r\npath1 = path2;\r\n```\r\n##### Arithmetic Operators\r\nMAP allows for standard arithmetic operators that can be used with the Numeric data type. These arithmetic operators include addition (+), subtraction (-), multiplication (*), division (/), and modulus (%). All of these are binary operators. A binary operator is of the form:\r\n```\r\nexpression binary-operator expression\r\n```\r\nHere are some examples of the arithmetic operators:\r\n```\r\nx = 4.67 + 38;\r\nx = (8.97 / 6.7) * (5 * 3.14);\r\nx = 7 % 5;\r\n```\r\nAll arithmetic operators are left associative, and the precedence goes multiplication and division, and then addition and subtraction.\r\n##### Relational Operators\r\nRelational operators are also binary operators, and can be used to form boolean expressions that can then be used in control flow. The relational operators are greater than (>), greater than or equal to (>=), less than (<), less than or equal to (<=), is equal to (==), and not equal to (!=). Each relational operator compares two expressions and returns true or false based on the validity of the statement. Examples of relational operators include:\r\n```\r\n3 <= 6                               // returns true\r\n(4 + (6.2 / 7.45)) > (1.96 * 2.01)   // returns true\r\n5 >= 6                               // returns false\r\n((1 + 2) * 3) == (1 + (2 * 3))       // returns false\r\n4 != 4.2                             // returns true\r\ngraph1 == graph2                     // returns true/false depending on the graphs\r\ngraph1 > graph2                      // returns true if graph1 has more nodes than graph2\r\n```\r\nGraphs and paths can be compared based on number of nodes. Comparing with (==) will return true if they have the same number of nodes. Edges and nodes cannot be compared with relational operators.\r\n##### Logical Operators\r\nLogical operators are binary operators that are also used to form boolean expressions used in control flow. The logical operators are logical AND (&), and logical OR (|). The operands to a logical operator must be booleans, and the expression evaluates to a boolean. Some examples include:\r\n```\r\ntrue & true       // returns true\r\ntrue | false      // returns true\r\nfalse & true      // returns false\r\n```\r\n##### Summary of Operators\r\n|   |          |\r\n|---|----------|\r\n| = | Assignment operator |\r\n| + | Numeric addition operator, binary, left-associative |\r\n| - | Numeric subtraction operator, binary, left-associative |\r\n| * | Numeric multiplication operator, binary, left-associative |\r\n| / | Numeric division operator, binary, left-associative |\r\n| % | Numeric modulus operator, binary, left-associative |\r\n| > >= < <= == != | Comparison operators, each operator returns true or false based on validity, used in control flow for creating expressions, binary operators, left-associative |\r\n| & | Logical AND operator, binary |\r\n| &#124; | Logical OR operator, binary |\r\n| ! | Logical NOT operator, unary |\r\n\r\n\r\n### Function Definitions\r\nOur MAP language allows users to define their own functions.  All function declarations must be defined immediately after the declaration. The format of the function declaration must first be the return type, an identifier, and finally comma-separated parameters enclosed within parentheses. A function can have any number of parameters which are all passed by value. Each parameter must also have a data type. In the function definition, there must be a single return statement that returns a value which corresponds to the return type of the function. Here is an example of a function declaration and definition:\r\n```\r\nfunc func_name(param_list) {\r\n\tfunc_body;\r\n\treturn val;\r\n}\r\n\r\nfunc factorial(Numeric n) {\r\n    Numeric i;\r\n    Numeric x = 1;\r\n    if (n == 0)\r\n        return 1;\r\n    for (i = 1; i <= n; i = i+1) {\r\n        x = x*i;\r\n    }\r\n    return x;\r\n}\r\n```\r\n\r\n\r\n### Statements\r\nA statement in the MAP language does not have a value, and except for those described, statements are executed in sequence.\r\n\r\n#### Assignments\r\nAn assignment statement will include a modifiable lvalue and an expression. When the assignment statement is executed, the expression will first be executed and then the result of this expression will be assigned to the lvalue.\r\n```\r\nlvalue = expression;\r\n```\r\n\r\n#### Function Calls\r\nA function call statement will execute the specified function, but ignore the return value of the function. If the return value should not be ignored, the return value of the function call can be captured with an assignment statement.\r\n```\r\nfunction(optionalParameters);\r\n```\r\n\r\n#### Compound Statement\r\nA compound statement is provided so that several statements can be used together.\r\n```\r\ncompound-statement:\r\n\t{ statement-list-E }\r\n\r\nstatement-list:\r\n\tstatement\r\n\tstatement-list statement\r\n```\r\n\r\n#### Selection Statement\r\n##### If-elif-else\r\n\r\nAn if-elif-else statement will execute the statement-list which has the first true boolean expression in the condition.\r\n```\r\nif (expression-1)\r\n{\r\n    statement-1-list\r\n}\r\nelif (expression-2)\r\n{\r\n    statement-2-list\r\n}\r\nelif (expression-n)\r\n{\r\n    statement-n-list\r\n}\r\nelse\r\n{\r\n    statement-else-list\r\n}\r\n```\r\nIn this example of the if-elif-else statement, if expression-1 is evaluated to true, then only statement-1-list will be executed. If expression-1 is false, then expression-2 in the elif-statement will be checked. If expression-2 evaluates to true, then only statement-2-list will be executed. This process will repeat for the second elif statement. If all the expressions evaluate to false, then statement-else-list will be executed. All elif and else statements are optional but if else is used, it must come after the elif statements. Additionally, an else statement will correspond with the last encountered else-less if.\r\n\r\n#### Iteration Statements\r\nThe for statement will have two forms:\r\n```\r\nfor (expression-1; expression-2; expression-3) statement\r\n```\r\nThe statement will be executed repeatedly as long as the value of expression-2 remains true. The evaluation of expression-2 will take place before the execution of the statement.\r\n```\r\nforeach (datatype-1 in datatype-2) { \r\n     statement;\r\n}\r\n```\r\nThis statement will be executed repeatedly until there is no longer any datatype-1 inside datatype-2.\r\n\r\n#### Jump Statements\r\n##### Break Statement\r\nA break statement will cause termination of the closest enclosing for statement. Control would then pass on to the next statement after the terminated loop.\r\n```\r\nbreak;\r\n```\r\n##### Continue Statement\r\nA continue statement will go to the next iteration of the closest enclosing for statement. Thus, this also can be thought of as causing an iteration of a loop to end.\r\n```\r\ncontinue;\r\n```\r\n##### Return Statement\r\n\r\nA return statement will end a function or return to the caller and can be in two forms:\r\n```\r\nreturn;\r\nreturn (expression);\r\n```\r\nThe first return statement has no value, but will end the function. The second return statement will have an expression that is evaluated and the result will be the return value of the function. If there is no return statement, the function would end as if the first return statement was at the end of the function. \r\n\r\n\r\n### Scope\r\n\r\n#### Scoping With Blocks\r\nA block is an area in which a variable is defined and accessible. MAP represents blocks using curly braces to show the context where a value or expression is valid. The use of curly braces gives MAP a Java/C/C++ look.\r\nIn MAP. variables are passed by value, as programmers should be able to work with copies of the Data Types (Edge, Graph, Node, Path) when passing these values into functions, instead of altering the actual data itself.\r\nMAP is statically/lexically scoped, meaning variables defined within a block not visible or accessible outside the block and variables outside the scope are still visible and accessible within the block. With lexical scope, a variable name refers to its local block and can be determined by studying the nested structure of the program.\r\nConsider this MAP code: \r\n```\r\nfunc main() {\r\n\tNumeric x = 1;\r\n\tNumeric z = 4; \r\n\tprint(x);\r\n\tfor (Numeric i = 0; i < 2; i = i + 1) {\r\n\t\tx = 2;\r\n\t\tNumeric y = 4; \r\n\t\tprint(x);\r\n\t\tprint(z);\r\n\t}\r\n\tprint(x);\r\n\t// if you called print(y) here, there would be an error because\r\n\t// y is not accessible here \r\n}\r\n```\r\nThe output should be:\r\n```\r\n1 2 4 2 4 2\r\n```\r\nx is defined throughout main, while y is defined only in the for loop. When z is called in the for-loop block, its declaration is searched for in that block, and when it is not found, it is searched for in the parent block. If z did not exist even in the parent block, an error would be thrown. \r\n\r\n#### Function Scope\r\nIn line with lexical scoping, a variable declared within a function is destroyed when a function returns. However, if a variable defined outside a function is modified within the function, the changes persist when the function returns.\r\n\r\n### Built-in Functions\r\nMAP includes various built-in functions that simplify graph programming. \r\n\r\n| Function | What it does |\r\n| ----- | ----- |\r\n| Graph.add(node) | Add a node to a graph, returns true on success |\r\n| Path.add(node) | Add a node to a path, returns true on success. When adding a node to a path, the order the nodes are added matters for the direction of the path |\r\n| Graph.delete(node) Path.delete(node) | Remove a node from a graph or path, returns true if node existed, otherwise false |\r\n| print(DataType) | Print given data type, can be a graph, node, edge, or primitive, returns null |\r\n| Graph.adjacent(node1, node2) Path.adjacent(node1, node2) | Returns whether the two nodes given are directly connected, returns true if the two nodes are adjacent, false otherwise |\r\n| Graph.path(node) | Return all nodes that are connected to this node, returns list of nodes (graph) |\r\n| Graph.getEdge(node1, node2) Path.getEdge(node1, node2) | Return an instance of the edge between the two nodes given, returns null if edge does not exist |\r\n| Graph.addEdge(edge) | Add an edge into the non-empty graph, returns true on success, false on error |\r\n| Graph.deleteEdge(node1, node2) | Deletes an edge in the non-empty graph, returns true if edge existed, false otherwise |\r\n| Graph.findShortest(node1, node2, attribute) | Finds the shortest path between two nodes in a graph and finds the shortest minimum value for an attribute, if the attribute is not null, returns a new Path object |\r\n| read(file) | Reads in a file with serialized Graph object, returns a new Graph object on success, null on error |\r\n| write(file, Graph) | Serializes Graph object to a file, returns true on success, false on error |\r\n| Graph.equals(Graph) | Returns true if both graphs are equal. Otherwise, returns false |\r\n| Path.equals(Path) | Returns true if both paths are equal. Otherwise, returns false | \r\n| Graph.draw(filename) | Draws a graph and saves it according to file name specified | \r\n| Path.printNodeDiagnostics() | Prints information about the node |\r\n| Path.printPathDiagnostics() | Prints information about the path |\r\n| Graph.printGraphDiagnostics() | Prints information about the graph |\r\n| Graph.nodesWithoutNeighbors() | Returns all unconnected nodes in the graph | \r\n\r\n### Preprocessing\r\n\r\n#### File Inclusion\r\nMAP allows one file to gain access to the contents of another file and utilize its functions through file inclusion. File inclusion should be performed at the top of the file, and only other .map files may be included. Additionally, though some languages like Python allow for inclusion of portions of a file (from MODULE import SUB-MODULE would only import SUB-MODULE), MAP does not allow for selective inclusion of a file’s contents.\r\n```\r\n// main.map\r\ninclude functions.map\r\nfunc main() {\r\n\tfunc_body;\r\n}\r\n```\r\n\r\n\r\n### Grammar\r\n```\r\ntranslation-unit: \r\n    external-declaration \r\n    translation-unit external-declaration \r\n \r\nexternal-declaration: \r\n    function-definition \r\n \r\nfunction-definition:\r\n    func identifier ( parameter-list ) {statement-list}\r\n\r\nidentifier:\r\n    ID\r\n    \r\nparameter-list:\r\n    type_declaration \r\n    parameter-list , type_declaration \r\n    ID\r\n    E\r\n    \r\ntype_declaration:\r\n    TYPE identifier\r\n\r\nstatement_list:\r\n    statement_list statement\r\n    statement\r\n    E\r\n\r\nstatement:\r\n    expression;\r\n    function_call;\r\n    selection_statement\r\n    for_loop\r\n    for_each\r\n    jump_stmt\r\n\r\nselection_statement:\r\n    if ( expression) {statement_list} sel_statement else_statement\r\n\r\nelse_statement:\r\n    else {statement_list}\r\n    E\r\n\r\nsel_statement:\r\n    sel_statement elif_statement\r\n    E\r\n\r\nelse_statement:\r\n    ELSE { statement_list}\r\n    E\r\n\r\nelif_statement:\r\n    elif (expression) {statement_list}\r\n    E\r\n\r\nfor_loop:\r\n    for (aexpr ; conditional_expression ; assignment_expression) {statement_list}\r\n\r\nfor_each:\r\n   foreach (TYPE identifier in identifier ) {statement_list }\r\n\r\njump_stmt:\r\n    break;\r\n    continue;\r\n    return assignment_expression;\r\n    return function_call;\r\n\r\nexpression:\r\n    assignment_expression\r\n    aexpr\r\n\r\naexpr:\r\n    TYPE identifier = LITERAL\r\n    TYPE identifier = NUMERIC\r\n    TYPE identifier = BOOLEAN\r\n    \r\nassignment_expression:\r\n    TYPE identifier = function_call\r\n    TYPE identifier = BOOLEAN\r\n    conditional_expression\r\n    primary_expression\r\n    struct_assignment\r\n    primary_expression = assignment_expression\r\n\r\nstruct_assignment:\r\n    TYPE identifier = new TYPE ( func_args )\r\n    \r\nconditional_expression:\r\n    logical_OR_expression\r\n    logical_AND_expression\r\n\r\nlogical_OR_expression: \r\n    logical_AND_expression\r\n    logical_OR_expression | logical_AND_expression\r\n\r\nlogical_AND_expression:\r\n    equality_expression\r\n    logical_AND_expression & equality_expression\r\n    \r\nequality_expression:\r\n    equality_expression == relational_expression\r\n    equality_expression != relational_expression\r\n    \r\nrelational_expression:\r\n    additive_expression\r\n    relational_expression > additive expression\r\n    relational_expression >= additive expression\r\n    relational_expression < additive expression\r\n    relational_expression <= additive expression\r\n\r\nadditive_expression:\r\n    multiplicative_expression\r\n    additive_expression + multiplicative_expression\r\n    additive_expression - multiplicative_expression\r\n\r\nmultiplicative_expression:\r\n    primary_expression\r\n    multiplicative_expression * primary_expression\r\n    multiplicative_expression / primary_expression\r\n    multiplicative_expression \\% primary_expression\r\n\r\nprimary_expression:\r\n    Identifier\r\n    LITERAL\r\n    Numeric\r\n    (expression)\r\n\r\nfunctional_call:\r\n    identifier.function_name(parameter_list)\r\n    identifier(func_args)\r\n    function(func_args)\r\n\r\nfunction:\r\n    print\r\n    input\r\n    write\r\n    read\r\n\r\nfunc_args:\r\n    arg\r\n    func_args , arg\r\n    func_args + arg\r\n    function_call\r\n    \r\n  \r\nargs:\r\n    LITERAL\r\n    Numeric\r\n    associative_arr\r\n  \r\nassociative_arr:\r\n    {array_values}\r\n\r\narray_values:\r\n    arrayval\r\n    array_values,arrayval\r\n    array_vals, array_vals\r\n\r\narrayval:\r\n    LITERAL : primary_expression\r\n   \r\narg:\r\n    ID\r\n    E\r\n\r\nfunction_name:\r\n    add\r\n    delete\r\n    adjacent\r\n    path\r\n    getEdge\r\n    addEdge\r\n    deleteEdge\r\n    findShortest\r\n    equals\r\n    draw\r\n    noNeighbors\r\n    nodesWithoutNeighbors\r\n    printGraphDiagnostics\r\n    printPathDiagnostics\r\n    printNodeDiagnostics\r\n```\r\n\r\n\r\n## Contributors                                                                                 \r\nSerena Simkus - Project Manager (@serenasimkus)                                                  \r\n\r\nSandya Sankarram - Language Guru                                                                 \r\n\r\nAlex Merkulov - System Architect                                                                 \r\n\r\nAlfred Tan - System Integrator                                                                   \r\n\r\nTommy Inouye - Verification & Validation Person\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}