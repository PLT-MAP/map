<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Map : Language Tutorial" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Map</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/PLT-MAP/map">View on GitHub</a>

          <h1 id="project_title">Map</h1>
          <h2 id="project_tagline">Language Tutorial</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/PLT-MAP/map/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/PLT-MAP/map/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>
<a name="language-tutorial" class="anchor" href="#language-tutorial"><span class="octicon octicon-link"></span></a>Language Tutorial</h2>

<h3>
<a name="introduction" class="anchor" href="#introduction"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>This will be a brief walkthrough of the mechanics of the MAP language. The aim is to show the essential elements of the language in real programs, without focusing too much on details, rules and exceptions. The ultimate goal is to allow users to attain the tools and skills to be able to write their own creative and useful programs.</p>

<p>In this brief tutorial, there will be several sample programs that demonstrate the multiple usages of the language. The main focus will be on the basics: variables and constants, arithmetic operations, control flow, functions, and the correct application of inputs and outputs. Specifically, a user will be able to learn how to implement the different graph data structures available in the language and learn how to quickly build nodes and edges without needing to know the specifics of how the graphs are implemented.</p>

<p>Experienced programmers should easily be able to extrapolate the material in this tutorial to meet their own programming needs. New users can easily pick up the basics of MAP by slowly building their knowledge by starting from small, similar programs and expanding to longer and more advanced programs. Either way, both subsets of programmers should be able to efficiently use this tutorial as a framework for any projects they wish to work on in the future. </p>

<h3>
<a name="input-and-output" class="anchor" href="#input-and-output"><span class="octicon octicon-link"></span></a>Input and Output</h3>

<p>The purpose of MAP is to create and implement graph data structures much more efficiently and easily. As such, the general output will be a visual representation of the graph in the form of an associative array. The input will usually be data entered by the user or from a file, and that will be used to populate the graph. To prompt a user, a programmer can use the command:</p>

<pre><code>input("prompt")
</code></pre>

<p>For a visual example of a undirected graph, please use the example below. Array 1 includes all the Nodes, and Array 2 includes the associate array of costs for each respective Node, so costs2 could be an associative array such as: </p>

<pre><code>('sanfran', {'cost':280,'duration':6})
</code></pre>

<p>and the information stored in Array 2 for this connection could be:</p>

<table>
<thead><tr>
<th>Array 1: Nodes</th>
<th>Array 2: Edges</th>
</tr></thead>
<tbody>
<tr>
<td>Node 1</td>
<td>('Node 2','Node 1',{costs2})</td>
</tr>
<tr>
<td>Node 2</td>
<td>('Node 1','Node 2',{costs3}), ('Node 3','Node 2',{costs4})</td>
</tr>
<tr>
<td>Node 3</td>
<td>('Node 4','Node 3',{costs5}), ('Node 2','Node 3',{costs6})</td>
</tr>
<tr>
<td>Node 4</td>
<td>('Node 2','Node 4',{costs7}), ('Node 3','Node 4',{costs8})</td>
</tr>
</tbody>
</table><pre><code>Graph g = new Graph():
</code></pre>

<p>Assume this graph is filled in with Nodes and Edges. Suppose if you wanted to print the graph out in a user-friendly and readable format, in MAP you would call: </p>

<pre><code>print(g);
</code></pre>

<p>This would print the graph out in a similar format to this: </p>

<pre><code>NODES
1. Node1
2. Node2
3. Node3
4. Node4

EDGES
(1-&gt;2)-costs2
(2-&gt;1)-costs3
(2-&gt;3)-costs4
(3-&gt;4)-costs5
(3-&gt;2)-costs6
(4-&gt;2)-costs7
(4-&gt;3)-costs8
</code></pre>

<p>The print function simplifies the programming and formatting issues that programmers usually face when doing graph programming. </p>

<p>Additionally, MAP allows for printing of Edge values, Node values, text values, and numeric values. </p>

<pre><code>    Node la = new Node({'temp':78});
    print(la);
</code></pre>

<p>would give:</p>

<pre><code>    ('la', {'temp':78})

    DirEdge flight234 = new DirEdge(newyork, sanfran, {'cost': 280,'duration': 6});
    print(flight234);
</code></pre>

<p>would give:</p>

<pre><code>    (newyork-&gt;sanfran) - cost: 280, duration: 6

    Text temp = " hello";
    Numeric num = 1; 
    print(num + temp);
</code></pre>

<p>would give:</p>

<pre><code>    1 hello
</code></pre>

<h3>
<a name="hello-world" class="anchor" href="#hello-world"><span class="octicon octicon-link"></span></a>Hello World</h3>

<p>To begin the tutorial on how to write programs in MAP, we will walk through the very simple, but standard, Hello World program. Program 1 is a Hello World program, which when compiled and run will print the sentence “Hello, World!”</p>

<pre><code>Program 1:
func main() {
    Text t = "Hello, World!";
    print(t);
}
</code></pre>

<p>The first line of this program is the declaration of the function called main. Every program in MAP needs a main function, which is what will be executed when the program is run. Every function declaration begins with the keyword func, followed by the function name, any parameters, and the bracket that begins (and later ends) the function body. </p>

<p>The second line of the program creates a variable t, of type Text, and stores the string “Hello, World!” in the variable as Text. Every line must be ended with a semicolon as well. </p>

<p>The third line uses the standard library function print, which can print any data type. The function print is passed the variable t, and the line is ended with a semicolon.</p>

<p>The last line simply contains the closing bracket, which signifies the end of the function. </p>

<p>This program is compiled and run by using the command:</p>

<pre><code>python Map.py helloworld.map
</code></pre>

<p>If everything goes as it is supposed to, “Hello, World!” should be printed to the console. </p>

<h3>
<a name="variables-and-expressions" class="anchor" href="#variables-and-expressions"><span class="octicon octicon-link"></span></a>Variables and Expressions</h3>

<p>Program 2 is a GCD program, which means it calculates the greatest common divisor of two numbers given. This program is slightly more complicated than the Hello World program, and will help show how other aspects of MAP are used, such as variables, expressions, and operators. </p>

<pre><code>Program 2:
func gcd(Numeric a, Numeric b) {
    if (b == 0) {
        return a;
    } else {
        return gcd(b, a % b);   // recursive call
    }
}

func main() {
    Numeric x = 3 + 5 * 14; // 73
    Numeric y = 89;

    Numeric result = gcd(x, y);
    print("The gcd of " + x + " and " + y + " is " + result);
}
</code></pre>

<p>The first thing to notice about this program is there are two separate functions, a function that does the GCD computation, and a main function. </p>

<p>The GCD function follows a simple algorithm that recursively calculates the GCD. The first line declares the function, which in this case takes in two parameters, both of type Numeric. The function body is started with the opening bracket. </p>

<p>The first line of the function makes use of an if statement, to check whether the parameter b passed in is equal to 0. This line is ended with another opening bracket, which in this case signifies the start of the body of the if statement. </p>

<p>The if statement body only has one line, which says to return the parameter a that was passed in, if the parameter b is equal to 0. This line is ended with a semicolon, which is then followed by a closing bracket to end the body of the if statement. </p>

<p>The if is then followed by an else, which has its own opening and closing brackets around its body as well. The body of the else is a line that has a return statement that returns a call to the same function, modifying the parameters by calling GCD with b, and a % b (a modulus b, returning the remainder from a divided by b) as the new parameters. </p>

<p>After the semicolon at the end of the line there is the special character constant \\. This symbolizes a comment, and is not part of the executed code. The function is ended with a closing bracket. </p>

<p>The main function begins with a function declaration and the opening bracket to start the body. The first two lines of the main declare two variables of type Numeric, and set them to numerical values. The first of these declarations shows operator precedence because multiplication has higher precedence than addition, so 5 * 14 is calculated before the 3 is added (the comment shows the value this should evaluate to, 73). The third line creates a variable called result to store the return from the function GCD, which is passed the variables created earlier. The last line of the main function prints this result out, and uses the + operator to concatenate strings with variables in order to print the output as one sentence. </p>

<p>This program is then compiled and run by typing the command:</p>

<pre><code>python map.py gcd.map
</code></pre>

<p>If all goes well, it should print out a sentence that gives the two numbers assigned to the variables in main, and the greatest common divisor of them. </p>

<h3>
<a name="control-flow" class="anchor" href="#control-flow"><span class="octicon octicon-link"></span></a>Control Flow</h3>

<h4>
<a name="if-elif-else-statements" class="anchor" href="#if-elif-else-statements"><span class="octicon octicon-link"></span></a>If-elif-else Statements</h4>

<p>To perform different actions based on different conditions, MAP supports if-elif-else statements to properly direct control flow.</p>

<pre><code>if (expression-1)
{
    statement-1-list
}
elif (expression-2)
{
    statement-2-list
}
else
{
    statement-else-list
}
</code></pre>

<p>Here is an example that implements this statement:</p>

<pre><code>if (n['temp'] &lt; 30 &amp; n['temp'] &gt; 0)
{
    graph1.add(n);
}
elif (n['temp'] &lt; 70)
{
    graph2.add(n);
}
else
{
    print("This location is too hot.");
}
</code></pre>

<p>If the temperature of a node is greater than 0, but less than 30, then the node will be added to graph1. However, if this expression is false, then the elif expression is checked. If the elif expression is true, then the node is added to graph 2. Otherwise, the else statement will be executed and the standard output will state “This location is too hot.”</p>

<h4>
<a name="loops" class="anchor" href="#loops"><span class="octicon octicon-link"></span></a>Loops</h4>

<p>Above, we learned about conditional statements, but now we will learn how to repeat statements by using two forms of the for loop.</p>

<p>Here is a simple example using the first for loop, which also demonstrates nested loops:</p>

<pre><code>for (int x = 0; x &lt; 10; x = x+1) {
    print(x + " ");
    for (int y = 0; y &lt; 10; y = y+1) {
        print(x*y + " ");
    }
}
</code></pre>

<p>This snippet of code will basically print out a small multiplication table. For both for loops, inside the parentheses the first expression initializes a variable, the second expression is a condition that must be true in order for the loop to continue, and the third expression increases the variable by  1. For each x in the outer loop, the x will be printed and then the result of the multiplication of x and the numbers 0 to 9 will also be printed. The numbers 0 to 9 come from y in the inner for loop.</p>

<p>Here is an example using the second for loop:</p>

<pre><code>foreach (Node n in graph1) {
    if (n['population'] &lt; 8000000) {
        graph2.add(n);
    }
}
</code></pre>

<p>A graph is made up of any number of nodes. Thus, in the foreach statement, it will keep repeating the statements in the loop until there are no more nodes in the graph. If there were no nodes in the graph initially, the foreach statement would not even execute. In the above example, a smaller subset of graph1 called graph2 is being created. For every node in graph1, if the population of the node is less than 8 million, that node will be added to graph2. The foreach statement could also be used with edges in graphs, nodes in paths, and edges in paths. </p>

<h3>
<a name="functions" class="anchor" href="#functions"><span class="octicon octicon-link"></span></a>Functions</h3>

<p>MAP allows users to define their own functions in order to enhance reusability and even readability by treating a specific computation as a unit and to allow this computation to be repeated. Even if a function is only used once, it often helps clarify a piece of code. </p>

<p>Here is the syntax for a function:</p>

<pre><code>func func_name(param_list) {
    func_body;
}
</code></pre>

<p>The param_list can have any number of arguments and the function can end with return (expression) or return. If there is no return statement, the function will simply end as if return was placed at the end of the function body. </p>

<p>Here is an example function that helps a user choose a location based on a budget:</p>

<pre><code>func printNodes(Node origin, Numeric budget, Graph graph) {
    foreach (Node n in graph) {
        if (graph.adjacent(origin, n)) {
            temp = graph.getEdge(origin,n);
            if (temp['cost'] &lt;= budget) {
                print(n);
            }
        }
    }
}
</code></pre>

<p>This function will loop through all the nodes in a certain graph, check if each node is adjacent to the origin specified, and if it is adjacent and the cost of the edge is less than or equal to the user’s budget, the location is printed out. </p>

<p>In order to call this function, we only have to use its name and put in the parameters with the correct data types. Here is an example:</p>

<pre><code>printNodes(newark, 1000, graph1);
</code></pre>

<p>This function is very reusable because the user can check different price ranges and even change the graph, which might have different attributes. Here is an example of a user checking different prices with different graphs:</p>

<pre><code>func main() {
    Graph graph1 = new Graph();
    Graph graph2 = new Graph();
    Node newark = new Node();
    graph1.add(newark);
    graph2.add(newark);
    printNodes(newark, 1000, graph1);
    printNodes(newark, 2000, graph2);
}
</code></pre>

<p>This is obviously a simple example without any direct results. However, with the creation of larger graphs, this function could become very useful. Another important aspect to point out is that a main function is required in MAP. All the code in the main function will be executed. Additionally, functions have to be declared in the program before they are called or there will be a compiler error. </p>

<h3>
<a name="create-your-own-graph" class="anchor" href="#create-your-own-graph"><span class="octicon octicon-link"></span></a>Create Your Own Graph</h3>

<p>Now that you are familiar with the basics of MAP - its variables, functions, file I/O, and control flow, we will focus on the driving motivation behind MAP's creation: the easy manipulation of graphs. In this section of the tutorial, we will create a graph, populate it with nodes, and see how MAP graphs utilize built-in and user-created functions. </p>

<h4>
<a name="graphs-in-map" class="anchor" href="#graphs-in-map"><span class="octicon octicon-link"></span></a>Graphs in MAP</h4>

<p>A graph is a set of nodes and their associated edges. A graph will be used to represent flights between various pairs of airports. Flights will be of DirEdge type, weighted by cost and duration, and airports will be Nodes, with specific characteristics like humidity and temperature. The reason that we use DirEdges (directed edges) instead of UndirEdges (undirected edges) is that flights imply a one direction movement. There might be up to two Flights associated with the same pair of cities; zero if the cities have no flight between them, one if there is a flight from city #1 to city #2 but not from city #2 to city #1, and two if there is a flight going both ways between the cities. </p>

<p>We start by creating an empty graph </p>

<pre><code>Graph flights = Graph(); 
</code></pre>

<p>To populate the graph with city's airports, we create nodes for airports:</p>

<pre><code>Node cabo    = new Node({'temp':85,'humidity':"low"});
Node miami   = new Node({'temp':87,'humidity':"high"});
Node ontario = new Node({'temp':45});
Node seattle = new Node({'temp':60,'humidity':"low"});
Node sanfran = new Node({'temp':75,'humidity':"low"});
Node newyork = newNode({'temp':50,'humidity':"medium"});
Node la      = new Node({'temp':78});
</code></pre>

<p>We then add these nodes to the graph:</p>

<pre><code>flights.add(cabo);
flights.add(miami);
flights.add(ontario);
flights.add(seattle);
flights.add(sanfran);
flights.add(newyork);
flights.add(la);
</code></pre>

<p>Note that, as our graph currently is, there is no connection among various airports, which is why we need to add edges to the graph between airports. Edges between two cities will be associated with two costs in our example: duration and cost. The DirEdges we use represent flights.</p>

<pre><code>DirEdge flight5 = new DirEdge(newyork, seattle, {'cost':330,'distance':4092,
                          'duration':6.5,'date':2014.03.14.6.25});
DirEdge flight9 = new DirEdge(newyork, la, {'cost':256,'duration':6});
DirEdge flight7 = new DirEdge(la, cabo, {'cost':180,'duration':2.5});
DirEdge flight234 = new DirEdge(newyork, sanfran, {'cost': 280,'duration': 6});
DirEdge flight49 = new DirEdge(seattle, cabo, {'cost':350,'duration':4.5});
</code></pre>

<p>Now add these edges to the graph to create connections among airports in our graph.</p>

<p>You can do this one edge at a time:</p>

<pre><code>flights.addEdge(flight5);
flights.addEdge(flight9);   
flights.addEdge(flight7);
flights.addEdge(flight234); 
flights.addEdge(flight49);
</code></pre>

<p>or all at once:</p>

<pre><code>flights.addEdge(flight5);
flights.addedge(flight9);
flights.addedge(flight7);
flights.addedge(flight234);
flights.addedge(flight49);
</code></pre>

<p>With our graph set up, we can now begin to use MAP's built-in library functions. For example, if we wanted to know if there was a flight between New York and Los Angeles, and if so, how much would that trip cost and how long it would take, we could use the getEdge() built-in method as follows:</p>

<pre><code>if (flights.getEdge(newyork, la) != null) {
    Edge temp = flights.getEdge(newyork, la);
    Text t = "There is a flight from";
    Text t2 = " to "; 
    Text t3 = "The cost is"; 
    Text t4 = " and the duration is ";
    print(t + temp['origin'] + t2 + temp['destination']);
    print(t3 + temp['cost'] + t4 + temp['duration']); 
}
</code></pre>

<p>Graph programming typically requires much more coding and debugging, but MAP allows users to not have to worry about building a graph from scratch, and lets them instead focus on the manipulation of these graphs to produce meaningful results. In addition to the example provided, users can also write their own functions to use on MAP graphs. Though our example explores a graph with directed edges, MAP graphs additionally support undirected edges for connections between nodes that are equivalent regardless of which Node is the origin and which is the destination. </p>

<h3>
<a name="conclusion" class="anchor" href="#conclusion"><span class="octicon octicon-link"></span></a>Conclusion</h3>

<p>This tutorial for MAP covers the essential parts of this programming language and hopefully assists programmers of all levels in acquiring all the right tools in using this language effectively to its full potential. It especially showcases all the unique aspects of MAP and offers a very basic understanding of MAP’s grammar and syntax. A more detailed analysis of the inner workings of this language can be found in the Language Reference Manual.</p>

<h2>
<a name="contributors" class="anchor" href="#contributors"><span class="octicon octicon-link"></span></a>Contributors</h2>

<p>Serena Simkus - Project Manager (<a href="https://github.com/serenasimkus" class="user-mention">@serenasimkus</a>)                                                  </p>

<p>Sandya Sankarram - Language Guru                                                                 </p>

<p>Alex Merkulov - System Architect                                                                 </p>

<p>Alfred Tan - System Integrator                                                                   </p>

<p>Tommy Inouye - Verification &amp; Validation Person</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Map maintained by <a href="https://github.com/PLT-MAP">PLT-MAP</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
