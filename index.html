<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Map : Language Reference Manual" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Map</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/PLT-MAP/map">View on GitHub</a>

          <h1 id="project_title">Map</h1>
          <h2 id="project_tagline">Language Reference Manual</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/PLT-MAP/map/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/PLT-MAP/map/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="table-of-contents" class="anchor" href="#table-of-contents"><span class="octicon octicon-link"></span></a>Table of Contents</h1>

<ol>
<li>
<p><a href="#language-reference-manual">Language Reference Manual</a></p>

<p>1.1 <a href="#introduction">Introduction</a></p>

<p>1.2 <a href="#lexical-conventions">Lexical Conventions</a></p>

<p>1.3 <a href="#data-types">Data Types</a></p>

<p>1.4 <a href="#expressions">Expressions</a></p>

<p>1.5 <a href="#function-definitions">Function Definitions</a></p>

<p>1.6 <a href="#statements">Statements</a></p>

<p>1.7 <a href="#scope">Scope</a></p>

<p>1.8 <a href="#built-in-functions">Built-in Functions</a></p>

<p>1.9 <a href="#preprocessing">Preprocessing</a></p>

<p>1.10 <a href="#grammar">Grammar</a></p>
</li>
<li><p><a href="#contributors">Contributors</a></p></li>
</ol><h2>
<a name="language-reference-manual" class="anchor" href="#language-reference-manual"><span class="octicon octicon-link"></span></a>Language Reference Manual</h2>

<h3>
<a name="introduction" class="anchor" href="#introduction"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>This manual describes MAP: the first ever travel-dedicated graphing programming language. This is a reliable guide to the proposed language. Furthermore, it describes the numerous features that MAP will use to deal with the problems and complexities of creating a graph data structure. The manual starts with an overview of lexical conventions used within this language, and moves onto the language syntax, and finishes with the grammar that is used to parse MAP.</p>

<h3>
<a name="lexical-conventions" class="anchor" href="#lexical-conventions"><span class="octicon octicon-link"></span></a>Lexical Conventions</h3>

<h4>
<a name="tokens" class="anchor" href="#tokens"><span class="octicon octicon-link"></span></a>Tokens</h4>

<p>Every program is parsed to a series of tokens. Each token can be broken down to several categories: primitives, data types, operators, and standard library functions. In addition we have a few reserved words as well as white space and tabs that are dealt with as separate tokens.</p>

<h4>
<a name="comments" class="anchor" href="#comments"><span class="octicon octicon-link"></span></a>Comments</h4>

<p>Map uses // for single line comments that will extend to a newline character. Block comments start with /* and end with */ and everything in between these two characters will be ignored.</p>

<h4>
<a name="identifiers" class="anchor" href="#identifiers"><span class="octicon octicon-link"></span></a>Identifiers</h4>

<p>An identifier can start with any letter, capital or lowercase, or an underscore. Every following character may include any letter, underscore or number. All identifiers are case sensitive and can be used to identify any basic or derived data types.</p>

<h4>
<a name="reserved-keywords" class="anchor" href="#reserved-keywords"><span class="octicon octicon-link"></span></a>Reserved Keywords</h4>

<p>The following are reserved for use as keywords and cannot be used otherwise.</p>

<table>
<thead><tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr></thead>
<tbody>
<tr>
<td>if</td>
<td>elif</td>
<td>else</td>
<td>for</td>
</tr>
<tr>
<td>foreach</td>
<td>null</td>
<td>break</td>
<td>return</td>
</tr>
<tr>
<td>continue</td>
<td>true</td>
<td>false</td>
<td>func</td>
</tr>
<tr>
<td>in</td>
<td>include</td>
<td></td>
<td></td>
</tr>
</tbody>
</table><h4>
<a name="reserved-characters" class="anchor" href="#reserved-characters"><span class="octicon octicon-link"></span></a>Reserved Characters</h4>

<p>The following characters are reserved for use in the grammar.</p>

<table>
<thead><tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr></thead>
<tbody>
<tr>
<td>+</td>
<td>-</td>
<td>*</td>
<td>/</td>
<td>%</td>
<td>[</td>
</tr>
<tr>
<td>]</td>
<td>(</td>
<td>)</td>
<td>{</td>
<td>}</td>
<td>&gt;</td>
</tr>
<tr>
<td>&gt;=</td>
<td>&lt;</td>
<td>&lt;=</td>
<td>==</td>
<td>!=</td>
<td>=</td>
</tr>
<tr>
<td>&amp;</td>
<td>|</td>
<td>,</td>
<td>.</td>
<td>//</td>
<td>/*</td>
</tr>
<tr>
<td>*/</td>
<td>;</td>
<td>:</td>
<td>'</td>
<td>"</td>
<td>!</td>
</tr>
</tbody>
</table><h4>
<a name="constants" class="anchor" href="#constants"><span class="octicon octicon-link"></span></a>Constants</h4>

<h5>
<a name="character-constants" class="anchor" href="#character-constants"><span class="octicon octicon-link"></span></a>Character Constants</h5>

<p>Character constants are strings whose values cannot be changed. Some special character constants can only be represented using the backslash escape character. Here are those special character constants:</p>

<table>
<thead><tr>
<th>Meaning</th>
<th>Character</th>
</tr></thead>
<tbody>
<tr>
<td>newline</td>
<td>\n</td>
</tr>
<tr>
<td>horizontal tab</td>
<td>\t</td>
</tr>
<tr>
<td>backslash</td>
<td>\</td>
</tr>
<tr>
<td>single quote</td>
<td>'</td>
</tr>
<tr>
<td>double quote</td>
<td>"</td>
</tr>
</tbody>
</table><h5>
<a name="boolean-constants" class="anchor" href="#boolean-constants"><span class="octicon octicon-link"></span></a>Boolean Constants</h5>

<p>Boolean constants are either true or false.</p>

<h3>
<a name="data-types" class="anchor" href="#data-types"><span class="octicon octicon-link"></span></a>Data Types</h3>

<p>MAP has three basic data types, and four derived data types that promote the use of graph data structures.</p>

<h4>
<a name="basic-data-types" class="anchor" href="#basic-data-types"><span class="octicon octicon-link"></span></a>Basic Data Types</h4>

<h5>
<a name="boolean" class="anchor" href="#boolean"><span class="octicon octicon-link"></span></a>Boolean</h5>

<p>Booleans can either be true or false. The default value of a boolean is false. </p>

<h5>
<a name="numeric" class="anchor" href="#numeric"><span class="octicon octicon-link"></span></a>Numeric</h5>

<p>The Numeric data type can hold any numeric value, including integers, doubles, floats, etc. MAP stores the values as floats, so it will handle as many decimal places and significant digits as allowed by the available memory on the machine. When values with decimals do not make sense, such as for indexing, the fractional part will be ignored. MAP simplifies primitive data types by lumping all numeric types into one type so that the user does not have to spend time thinking about which specific numeric type they will need. </p>

<h5>
<a name="text" class="anchor" href="#text"><span class="octicon octicon-link"></span></a>Text</h5>

<p>Any string, or any sequence of characters, surrounded by double quotes. </p>

<h4>
<a name="derived-data-types" class="anchor" href="#derived-data-types"><span class="octicon octicon-link"></span></a>Derived Data Types</h4>

<p>Since MAP is focused around making graph data structures easier to implement, there are many derived data types that are related to graphs. </p>

<h5>
<a name="edge" class="anchor" href="#edge"><span class="octicon octicon-link"></span></a>Edge</h5>

<p>The Edge data type is used to represent an edge in a graph. There are two types of edges, directed edges and undirected edges. All edges have specified origin and destination nodes, and associated costs. When the user creates a directed edge, the order of the nodes listed matters because that is the direction, from source to destination. When the user creates an undirected edge they will just put in two nodes, and behind the scenes we will just create two directed edges, one going in each direction, to create their “undirected edge”. The associated cost attributes, origin, and destination are stored in associative arrays so they can be accessed with string indices. This will be done in the back end while the user will not have to write 'origin' and 'destination' to simplify the syntax.  Initializing a directed edge looks like this:</p>

<pre><code>DirEdge flight5 = DirEdge('newyork','seattle',
                          {'cost':330,'distance':4092,'duration':6.5});
</code></pre>

<p>where flight5 is the name of the edge, newyork is the origin node, seattle is the destination node, and the associative array holds the attributes of the edge, labeled cost, distance, duration, and date. An undirected edge will be initialized the same way, except the data type is UnDirEdge. </p>

<h5>
<a name="graph" class="anchor" href="#graph"><span class="octicon octicon-link"></span></a>Graph</h5>

<p>The Graph data type represents a graph as a whole, containing nodes and edges. A graph can be initialized without any nodes or edges, and nodes and edges are added to the graph using built-in library functions. Initializing a graph called trip looks like this:</p>

<pre><code>Graph trip = Graph();
</code></pre>

<p>Graphs will store their nodes and edges in an adjacency list with the associative array of costs related to the edge in the list. </p>

<h5>
<a name="node" class="anchor" href="#node"><span class="octicon octicon-link"></span></a>Node</h5>

<p>The Node data type is used to represent a node in a graph. Nodes also have associative arrays to store attributes. Initializing a node looks like this:</p>

<pre><code>Node cabo = Node({'temp':85,'humidity':"low"});
</code></pre>

<p>where the name of the node is cabo, and it has attributes of temp and humidity. </p>

<h5>
<a name="path" class="anchor" href="#path"><span class="octicon octicon-link"></span></a>Path</h5>

<p>The Path data type is an ordered list of Nodes that provides a route from some start node to some end node. This can be used in finding a path through a graph such as the shortest path based on a specific cost attribute, or the path from one node to another node with specific attributes. Paths will be stored as lists, and will be created in the order that the path flows, from one node to another. Users can initialize paths like:</p>

<pre><code>Path roadTrip = Path(graphName);
</code></pre>

<p>The user passes in a parameter to specify which graph the path is associated with. The user can then add in nodes along the path from a graph. </p>

<h3>
<a name="expressions" class="anchor" href="#expressions"><span class="octicon octicon-link"></span></a>Expressions</h3>

<h4>
<a name="primary" class="anchor" href="#primary"><span class="octicon octicon-link"></span></a>Primary</h4>

<p>An expression consists of at least one operand and zero or more operators. Operands can be made from any numeric values, constants, variables, or functions that return values. Parentheses can group subexpressions. Expressions are evaluated from left to right. Examples of expressions are:</p>

<pre><code>3.14159
4 + 13
(((2 + 10) / (12 + 4)) * (27 - 14)) * 3.9
</code></pre>

<h4>
<a name="operators" class="anchor" href="#operators"><span class="octicon octicon-link"></span></a>Operators</h4>

<p>Operators can be combined with operands to make expressions. </p>

<h5>
<a name="assignment-operators" class="anchor" href="#assignment-operators"><span class="octicon octicon-link"></span></a>Assignment Operators</h5>

<p>The assignment operator is used to assign a value to a specified variable.</p>

<pre><code>x = 3.1415;
y = (2.9 * 1.3);
graph1 = graph2;
node1 = node2;
edge1 = edge2;
path1 = path2;
</code></pre>

<h5>
<a name="arithmetic-operators" class="anchor" href="#arithmetic-operators"><span class="octicon octicon-link"></span></a>Arithmetic Operators</h5>

<p>MAP allows for standard arithmetic operators that can be used with the Numeric data type. These arithmetic operators include addition (+), subtraction (-), multiplication (*), division (/), and modulus (%). All of these are binary operators. A binary operator is of the form:</p>

<pre><code>expression binary-operator expression
</code></pre>

<p>Here are some examples of the arithmetic operators:</p>

<pre><code>x = 4.67 + 38;
x = (8.97 / 6.7) * (5 * 3.14);
x = 7 % 5;
</code></pre>

<p>All arithmetic operators are left associative, and the precedence goes multiplication and division, and then addition and subtraction.</p>

<h5>
<a name="relational-operators" class="anchor" href="#relational-operators"><span class="octicon octicon-link"></span></a>Relational Operators</h5>

<p>Relational operators are also binary operators, and can be used to form boolean expressions that can then be used in control flow. The relational operators are greater than (&gt;), greater than or equal to (&gt;=), less than (&lt;), less than or equal to (&lt;=), is equal to (==), and not equal to (!=). Each relational operator compares two expressions and returns true or false based on the validity of the statement. Examples of relational operators include:</p>

<pre><code>3 &lt;= 6                               // returns true
(4 + (6.2 / 7.45)) &gt; (1.96 * 2.01)   // returns true
5 &gt;= 6                               // returns false
((1 + 2) * 3) == (1 + (2 * 3))       // returns false
4 != 4.2                             // returns true
graph1 == graph2                     // returns true/false depending on the graphs
graph1 &gt; graph2                      // returns true if graph1 has more nodes than graph2
</code></pre>

<p>Graphs and paths can be compared based on number of nodes. Comparing with (==) will return true if they have the same number of nodes. Edges and nodes cannot be compared with relational operators.</p>

<h5>
<a name="logical-operators" class="anchor" href="#logical-operators"><span class="octicon octicon-link"></span></a>Logical Operators</h5>

<p>Logical operators are binary operators that are also used to form boolean expressions used in control flow. The logical operators are logical AND (&amp;), and logical OR (|). The operands to a logical operator must be booleans, and the expression evaluates to a boolean. Some examples include:</p>

<pre><code>true &amp; true       // returns true
true | false      // returns true
false &amp; true      // returns false
</code></pre>

<h5>
<a name="summary-of-operators" class="anchor" href="#summary-of-operators"><span class="octicon octicon-link"></span></a>Summary of Operators</h5>

<table>
<thead><tr>
<th></th>
<th></th>
</tr></thead>
<tbody>
<tr>
<td>=</td>
<td>Assignment operator</td>
</tr>
<tr>
<td>+</td>
<td>Numeric addition operator, binary, left-associative</td>
</tr>
<tr>
<td>-</td>
<td>Numeric subtraction operator, binary, left-associative</td>
</tr>
<tr>
<td>*</td>
<td>Numeric multiplication operator, binary, left-associative</td>
</tr>
<tr>
<td>/</td>
<td>Numeric division operator, binary, left-associative</td>
</tr>
<tr>
<td>%</td>
<td>Numeric modulus operator, binary, left-associative</td>
</tr>
<tr>
<td>&gt; &gt;= &lt; &lt;= == !=</td>
<td>Comparison operators, each operator returns true or false based on validity, used in control flow for creating expressions, binary operators, left-associative</td>
</tr>
<tr>
<td>&amp;</td>
<td>Logical AND operator, binary</td>
</tr>
<tr>
<td>|</td>
<td>Logical OR operator, binary</td>
</tr>
<tr>
<td>!</td>
<td>Logical NOT operator, unary</td>
</tr>
</tbody>
</table><h3>
<a name="function-definitions" class="anchor" href="#function-definitions"><span class="octicon octicon-link"></span></a>Function Definitions</h3>

<p>Our MAP language allows users to define their own functions.  All function declarations must be defined immediately after the declaration. The format of the function declaration must first be the return type, an identifier, and finally comma-separated parameters enclosed within parentheses. A function can have any number of parameters which are all passed by value. Each parameter must also have a data type. In the function definition, there must be a single return statement that returns a value which corresponds to the return type of the function. Here is an example of a function declaration and definition:</p>

<pre><code>func func_name(param_list) {
    func_body;
    return val;
}

func factorial(Numeric n) {
    Numeric i;
    Numeric x = 1;
    if (n == 0)
        return 1;
    for (i = 1; i &lt;= n; i = i+1) {
        x = x*i;
    }
    return x;
}
</code></pre>

<h3>
<a name="statements" class="anchor" href="#statements"><span class="octicon octicon-link"></span></a>Statements</h3>

<p>A statement in the MAP language does not have a value, and except for those described, statements are executed in sequence.</p>

<h4>
<a name="assignments" class="anchor" href="#assignments"><span class="octicon octicon-link"></span></a>Assignments</h4>

<p>An assignment statement will include a modifiable lvalue and an expression. When the assignment statement is executed, the expression will first be executed and then the result of this expression will be assigned to the lvalue.</p>

<pre><code>lvalue = expression;
</code></pre>

<h4>
<a name="function-calls" class="anchor" href="#function-calls"><span class="octicon octicon-link"></span></a>Function Calls</h4>

<p>A function call statement will execute the specified function, but ignore the return value of the function. If the return value should not be ignored, the return value of the function call can be captured with an assignment statement.</p>

<pre><code>function(optionalParameters);
</code></pre>

<h4>
<a name="compound-statement" class="anchor" href="#compound-statement"><span class="octicon octicon-link"></span></a>Compound Statement</h4>

<p>A compound statement is provided so that several statements can be used together.</p>

<pre><code>compound-statement:
    { statement-list-E }

statement-list:
    statement
    statement-list statement
</code></pre>

<h4>
<a name="selection-statement" class="anchor" href="#selection-statement"><span class="octicon octicon-link"></span></a>Selection Statement</h4>

<h5>
<a name="if-elif-else" class="anchor" href="#if-elif-else"><span class="octicon octicon-link"></span></a>If-elif-else</h5>

<p>An if-elif-else statement will execute the statement-list which has the first true boolean expression in the condition.</p>

<pre><code>if (expression-1)
{
    statement-1-list
}
elif (expression-2)
{
    statement-2-list
}
elif (expression-n)
{
    statement-n-list
}
else
{
    statement-else-list
}
</code></pre>

<p>In this example of the if-elif-else statement, if expression-1 is evaluated to true, then only statement-1-list will be executed. If expression-1 is false, then expression-2 in the elif-statement will be checked. If expression-2 evaluates to true, then only statement-2-list will be executed. This process will repeat for the second elif statement. If all the expressions evaluate to false, then statement-else-list will be executed. All elif and else statements are optional but if else is used, it must come after the elif statements. Additionally, an else statement will correspond with the last encountered else-less if.</p>

<h4>
<a name="iteration-statements" class="anchor" href="#iteration-statements"><span class="octicon octicon-link"></span></a>Iteration Statements</h4>

<p>The for statement will have two forms:</p>

<pre><code>for (expression-1; expression-2; expression-3) statement
</code></pre>

<p>The statement will be executed repeatedly as long as the value of expression-2 remains true. The evaluation of expression-2 will take place before the execution of the statement.</p>

<pre><code>foreach (datatype-1 in datatype-2) { 
     statement;
}
</code></pre>

<p>This statement will be executed repeatedly until there is no longer any datatype-1 inside datatype-2.</p>

<h4>
<a name="jump-statements" class="anchor" href="#jump-statements"><span class="octicon octicon-link"></span></a>Jump Statements</h4>

<h5>
<a name="break-statement" class="anchor" href="#break-statement"><span class="octicon octicon-link"></span></a>Break Statement</h5>

<p>A break statement will cause termination of the closest enclosing for statement. Control would then pass on to the next statement after the terminated loop.</p>

<pre><code>break;
</code></pre>

<h5>
<a name="continue-statement" class="anchor" href="#continue-statement"><span class="octicon octicon-link"></span></a>Continue Statement</h5>

<p>A continue statement will go to the next iteration of the closest enclosing for statement. Thus, this also can be thought of as causing an iteration of a loop to end.</p>

<pre><code>continue;
</code></pre>

<h5>
<a name="return-statement" class="anchor" href="#return-statement"><span class="octicon octicon-link"></span></a>Return Statement</h5>

<p>A return statement will end a function or return to the caller and can be in two forms:</p>

<pre><code>return;
return (expression);
</code></pre>

<p>The first return statement has no value, but will end the function. The second return statement will have an expression that is evaluated and the result will be the return value of the function. If there is no return statement, the function would end as if the first return statement was at the end of the function. </p>

<h3>
<a name="scope" class="anchor" href="#scope"><span class="octicon octicon-link"></span></a>Scope</h3>

<h4>
<a name="scoping-with-blocks" class="anchor" href="#scoping-with-blocks"><span class="octicon octicon-link"></span></a>Scoping With Blocks</h4>

<p>A block is an area in which a variable is defined and accessible. MAP represents blocks using curly braces to show the context where a value or expression is valid. The use of curly braces gives MAP a Java/C/C++ look.
In MAP. variables are passed by value, as programmers should be able to work with copies of the Data Types (Edge, Graph, Node, Path) when passing these values into functions, instead of altering the actual data itself.
MAP is statically/lexically scoped, meaning variables defined within a block not visible or accessible outside the block and variables outside the scope are still visible and accessible within the block. With lexical scope, a variable name refers to its local block and can be determined by studying the nested structure of the program.
Consider this MAP code: </p>

<pre><code>func main() {
    Numeric x = 1;
    Numeric z = 4; 
    print(x);
    for (Numeric i = 0; i &lt; 2; i = i + 1) {
        x = 2;
        Numeric y = 4; 
        print(x);
        print(z);
    }
    print(x);
    // if you called print(y) here, there would be an error because
    // y is not accessible here 
}
</code></pre>

<p>The output should be:</p>

<pre><code>1 2 4 2 4 2
</code></pre>

<p>x is defined throughout main, while y is defined only in the for loop. When z is called in the for-loop block, its declaration is searched for in that block, and when it is not found, it is searched for in the parent block. If z did not exist even in the parent block, an error would be thrown. </p>

<h4>
<a name="function-scope" class="anchor" href="#function-scope"><span class="octicon octicon-link"></span></a>Function Scope</h4>

<p>In line with lexical scoping, a variable declared within a function is destroyed when a function returns. However, if a variable defined outside a function is modified within the function, the changes persist when the function returns.</p>

<h3>
<a name="built-in-functions" class="anchor" href="#built-in-functions"><span class="octicon octicon-link"></span></a>Built-in Functions</h3>

<p>MAP includes various built-in functions that simplify graph programming. </p>

<table>
<thead><tr>
<th>Function</th>
<th>What it does</th>
</tr></thead>
<tbody>
<tr>
<td>Graph.add(node)</td>
<td>Add a node to a graph, returns true on success</td>
</tr>
<tr>
<td>Path.add(node)</td>
<td>Add a node to a path, returns true on success. When adding a node to a path, the order the nodes are added matters for the direction of the path</td>
</tr>
<tr>
<td>Graph.delete(node) Path.delete(node)</td>
<td>Remove a node from a graph or path, returns true if node existed, otherwise false</td>
</tr>
<tr>
<td>print(DataType)</td>
<td>Print given data type, can be a graph, node, edge, or primitive, returns null</td>
</tr>
<tr>
<td>Graph.adjacent(node1, node2) Path.adjacent(node1, node2)</td>
<td>Returns whether the two nodes given are directly connected, returns true if the two nodes are adjacent, false otherwise</td>
</tr>
<tr>
<td>Graph.path(node)</td>
<td>Return all nodes that are connected to this node, returns list of nodes (graph)</td>
</tr>
<tr>
<td>Graph.getEdge(node1, node2) Path.getEdge(node1, node2)</td>
<td>Return an instance of the edge between the two nodes given, returns null if edge does not exist</td>
</tr>
<tr>
<td>Graph.addEdge(edge)</td>
<td>Add an edge into the non-empty graph, returns true on success, false on error</td>
</tr>
<tr>
<td>Graph.deleteEdge(node1, node2)</td>
<td>Deletes an edge in the non-empty graph, returns true if edge existed, false otherwise</td>
</tr>
<tr>
<td>Graph.findShortest(node1, node2, attribute)</td>
<td>Finds the shortest path between two nodes in a graph and finds the shortest minimum value for an attribute, if the attribute is not null, returns a new Path object</td>
</tr>
<tr>
<td>read(file)</td>
<td>Reads in a file with serialized Graph object, returns a new Graph object on success, null on error</td>
</tr>
<tr>
<td>write(file, Graph)</td>
<td>Serializes Graph object to a file, returns true on success, false on error</td>
</tr>
<tr>
<td>Graph.equals(Graph)</td>
<td>Returns true if both graphs are equal. Otherwise, returns false</td>
</tr>
<tr>
<td>Path.equals(Path)</td>
<td>Returns true if both paths are equal. Otherwise, returns false</td>
</tr>
<tr>
<td>Graph.draw(filename)</td>
<td>Draws a graph and saves it according to file name specified</td>
</tr>
<tr>
<td>Path.printNodeDiagnostics()</td>
<td>Prints information about the node</td>
</tr>
<tr>
<td>Path.printPathDiagnostics()</td>
<td>Prints information about the path</td>
</tr>
<tr>
<td>Graph.printGraphDiagnostics()</td>
<td>Prints information about the graph</td>
</tr>
<tr>
<td>Graph.nodesWithoutNeighbors()</td>
<td>Returns all unconnected nodes in the graph</td>
</tr>
</tbody>
</table><h3>
<a name="preprocessing" class="anchor" href="#preprocessing"><span class="octicon octicon-link"></span></a>Preprocessing</h3>

<h4>
<a name="file-inclusion" class="anchor" href="#file-inclusion"><span class="octicon octicon-link"></span></a>File Inclusion</h4>

<p>MAP allows one file to gain access to the contents of another file and utilize its functions through file inclusion. File inclusion should be performed at the top of the file, and only other .map files may be included. Additionally, though some languages like Python allow for inclusion of portions of a file (from MODULE import SUB-MODULE would only import SUB-MODULE), MAP does not allow for selective inclusion of a file’s contents.</p>

<pre><code>// main.map
include functions.map
func main() {
    func_body;
}
</code></pre>

<h3>
<a name="grammar" class="anchor" href="#grammar"><span class="octicon octicon-link"></span></a>Grammar</h3>

<pre><code>translation-unit: 
    external-declaration 
    translation-unit external-declaration 

external-declaration: 
    function-definition 

function-definition:
    func identifier ( parameter-list ) {statement-list}

identifier:
    ID

parameter-list:
    type_declaration 
    parameter-list , type_declaration 
    ID
    E

type_declaration:
    TYPE identifier

statement_list:
    statement_list statement
    statement
    E

statement:
    expression;
    function_call;
    selection_statement
    for_loop
    for_each
    jump_stmt

selection_statement:
    if ( expression) {statement_list} sel_statement else_statement

else_statement:
    else {statement_list}
    E

sel_statement:
    sel_statement elif_statement
    E

else_statement:
    ELSE { statement_list}
    E

elif_statement:
    elif (expression) {statement_list}
    E

for_loop:
    for (aexpr ; conditional_expression ; assignment_expression) {statement_list}

for_each:
   foreach (TYPE identifier in identifier ) {statement_list }

jump_stmt:
    break;
    continue;
    return assignment_expression;
    return function_call;

expression:
    assignment_expression
    aexpr

aexpr:
    TYPE identifier = LITERAL
    TYPE identifier = NUMERIC
    TYPE identifier = BOOLEAN

assignment_expression:
    TYPE identifier = function_call
    TYPE identifier = BOOLEAN
    conditional_expression
    primary_expression
    struct_assignment
    primary_expression = assignment_expression

struct_assignment:
    TYPE identifier = new TYPE ( func_args )

conditional_expression:
    logical_OR_expression
    logical_AND_expression

logical_OR_expression: 
    logical_AND_expression
    logical_OR_expression | logical_AND_expression

logical_AND_expression:
    equality_expression
    logical_AND_expression &amp; equality_expression

equality_expression:
    equality_expression == relational_expression
    equality_expression != relational_expression

relational_expression:
    additive_expression
    relational_expression &gt; additive expression
    relational_expression &gt;= additive expression
    relational_expression &lt; additive expression
    relational_expression &lt;= additive expression

additive_expression:
    multiplicative_expression
    additive_expression + multiplicative_expression
    additive_expression - multiplicative_expression

multiplicative_expression:
    primary_expression
    multiplicative_expression * primary_expression
    multiplicative_expression / primary_expression
    multiplicative_expression \% primary_expression

primary_expression:
    Identifier
    LITERAL
    Numeric
    (expression)

functional_call:
    identifier.function_name(parameter_list)
    identifier(func_args)
    function(func_args)

function:
    print
    input
    write
    read

func_args:
    arg
    func_args , arg
    func_args + arg
    function_call


args:
    LITERAL
    Numeric
    associative_arr

associative_arr:
    {array_values}

array_values:
    arrayval
    array_values,arrayval
    array_vals, array_vals

arrayval:
    LITERAL : primary_expression

arg:
    ID
    E

function_name:
    add
    delete
    adjacent
    path
    getEdge
    addEdge
    deleteEdge
    findShortest
    equals
    draw
    noNeighbors
    nodesWithoutNeighbors
    printGraphDiagnostics
    printPathDiagnostics
    printNodeDiagnostics
</code></pre>

<h2>
<a name="contributors" class="anchor" href="#contributors"><span class="octicon octicon-link"></span></a>Contributors</h2>

<p>Serena Simkus - Project Manager (<a href="https://github.com/serenasimkus" class="user-mention">@serenasimkus</a>)                                                  </p>

<p>Sandya Sankarram - Language Guru                                                                 </p>

<p>Alex Merkulov - System Architect                                                                 </p>

<p>Alfred Tan - System Integrator                                                                   </p>

<p>Tommy Inouye - Verification &amp; Validation Person</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Map maintained by <a href="https://github.com/PLT-MAP">PLT-MAP</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
